#!/bin/bash
#

if [ $# -eq 0 ]; then
  set -- --help
fi

OPTS_SPEC="\
git gl <options> <command>

When executing gitolite commands, you should not provide the repository:
this is filled in automaticly.
--
help      show the help
info      show information on the current repository.
d         show debug messages
r,remote=  remote to use as git host. you can also use gitolite.remote to set this.
h,host=   hostname to use as git host. overrides remote and can also be set as gitolite.host.
p,port=   port to use for ssh connection.
u,user=   use this user to access the remote host. overrides the remote and can also be set as gitolite.user.
repo=     remote repo to use. overrides the remote and can also be set as gitolite.repo.
"

eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt --stop-at-non-option -- "$@" || echo exit $?)"
PATH=$PATH:$(git --exec-path)
SUBDIRECTORY_OK=1
. git-sh-setup

require_work_tree

remote=
debug=
user=
host=
repo=
port=
protocol=
showinfo=0

config_remote="$(git config --get gitolite.remote || echo 'UNSET')"
config_host="$(git config --get gitolite.host || echo 'UNSET')"
config_user="$(git config --get gitolite.user || echo 'UNSET')"
config_repo="$(git config --get gitolite.repo || echo 'UNSET')"
config_port="$(git config --get gitolite.port || echo 'UNSET')"


debug() {
  if [ -n "${debug}" ]; then
    echo "$@" >&2
  fi;
}


get_component_from_remote() {
  local component="$2"
  local remote="$1"
  local url=$( get_url_from_remote $remote )
  if [ -z "$url" ]; then
    echo 'ERROR';
    return 1;
  fi

  local breakdown=$( echo $url | sed -r 's@^(([a-z]+)://)?(((\w+)\@)?([^:/]+))(\:([0-9]+))?[:/](.*)$@proto:\2\nuser:\5\nhost:\6\nport:\8\nrepo:\9\n@' )
  if echo "$breakdown" | grep -q "^${component}:"; then
    value=$( echo "$breakdown" | grep "^${component}:" );
    echo "${value#*:}"
  else
    echo "Could not parse the url '${url}' for remote '${remote}'" >&2;
    echo 'ERROR';
    exit 1;
  fi
}

get_url_from_remote() {
  local remote=$1;
  local url;
  if git remote | grep -q "^${remote}\$"; then
    url=`git remote show -n $remote | grep 'Push' | sed 's@.*URL\:\s\+\(.*\)$@\1@'`
    if [ -z $url ]; then
      echo "Could not determine the url of remote '${remote}'" >&2;
      exit 1;
    else
      cached_url="$url"
      echo $url;
    fi;
  else
    echo "Could not find remote '${remote}' configured in this repository" >&2;
    exit 1;
  fi;

}


while [ $# -gt 0 ]; do
  opt="$1";
  shift;
  case "$opt" in
    (-d)      debug=1 ;;
    (-r)      remote="$1"; shift ;;
    (-h)      host="$1"; shift ;;
    (-u)      user="$1"; shift ;;
    (--repo)  repo="$1"; shift ;;
    (-p)      port="$1"; shift ;;
    (--info)  showinfo=1; shift;;
    ([^-]*)   break;;
    (--)      break ;;
    (-*)       die "Unexpected option: $opt" ;;
  esac
done

command="$@"


debug "config_remote: {$config_remote}"
debug "config_host: {$config_host}"
debug "config_user: {$config_user}"
debug "config_repo: {$config_repo}"
debug "config_port: {$config_port}"

## Check which remote to use if needed.
if [ -z $remote ]; then
  [ "$config_remote" == 'UNSET' ] && remote=origin || remote=$config_remote;
fi

## Check which user to use.
if [ -z "$user" ]; then
  if [ "$config_user" != 'UNSET' ]; then
    user=$config_user;
  else
    user=$( get_component_from_remote $remote  'user' )
    value_from_remote=1
  fi;
fi;
[ "$user" == 'ERROR' ] && exit 1;

## Check which host to use
if [ -z $host ]; then
  if [ "$config_host" != 'UNSET' ]; then
    host=$config_host;
  else
    host=$( get_component_from_remote $remote 'host')
    value_from_remote=1
  fi;
fi
[ "$host" == 'ERROR' ] && exit 1;


## Check which repository we are in.
if [ -z $repo ]; then
  if [ "$config_repo" != 'UNSET' ]; then
    repo=$config_repo;
  else
    repo=$( get_component_from_remote $remote 'repo');
    value_from_remote=1
  fi;
fi;
[ "$repo" == 'ERROR' ] && exit 1;

if [ -z $port]; then
  if [ "$config_port" != 'UNSET' ]; then
    port=$config_port;
  else
    port=$( get_component_from_remote $remote 'port');
    port_from_remote=1
  fi;
fi
[ "$port" == 'ERROR' ] && exit 1;

debug "remote: {$remote}"
debug "user: {$user}"
debug "host: {$host}"
debug "repo: {$repo}"
debug "port: {$port}"
debug "value_from_remote: {$value_from_remote}"



if [ ${value_from_remote} == "1" ]; then
  protocol=$( get_component_from_remote $remote 'proto' );
  debug "protocol: {$protocol}";
  [ "$protocol" == 'ERROR' ] && exit 1;
  if [[ -n $protocol && $protocol != 'ssh' ]]; then
    echo "WARNING: The remote ${remote} does not use ssh!" >&2
    if [[ -n $port && $port_from_remote == "1" ]]; then
      echo "WARNING: The remote is not a ssh host, I can probably not use the same port!" >&2
    fi;
  fi
fi

translate_gitolite() {
  local command=$1;
  shift;
  local translated;
  case $command in
    ## ========== internal commands =========
    (info)        translated="$command";;
    ## ========== access ==========
    (access)      if [ -n "$2" ]; then
                    translated="$command $repo $*";
                  else
                    translated="$command -h";
                  fi;
    ;;
    ## ========== create ==========
    (create)      translated="$command $repo";;
    ## ========== D ==========
    (D)
      case $1 in
        (rm|lock|unlock|trash)    translated="$command $* $repo";;
        (*)                       translated="$command $*";;
      esac
    ;;
    ## ========== desc ==========
    (desc)        translated="$command $repo $*"
    ;;
    ## ========== owns =========
    (owns)        translated="$command $repo"
    ;;
    ## ========== perms =========
    (perms)
      case $1 in
        (-l)       translated="$command -l ${repo%.git}";;
        (-h)       translated="$command -h";;
        ('')       translated="$command";;
        (*)        translated="$command ${repo%.git} $*";;
      esac
    ;;
    (web)         translated="$command $repo $*";;
    ## ========== Fallthrough =========
    (*)
        echo "WARNING: Command ${command} is not explicitly supported by git-gl" >&2
        translated="$command $*"
        ;;
  esac
  echo $translated;
}

get_cmd() {
  local command=$1;
  local user=$2;
  local host=$3;
  local port=$4;
  local cmd
  cmd="ssh"
  [ -n "$port" ] && cmd="$cmd -p ${port} "
  [ -n "$user" ] && cmd="$cmd ${user}@" || cmd="$cmd "
  cmd="${cmd}${host}"
  real_cmd=$( translate_gitolite $command )
  cmd="$cmd ${real_cmd}"
  echo "$cmd | $real_cmd"
}

if [ "$showinfo" == "1" ]; then
  echo "=== Configuration ==="
  git config --get-regexp "gitolite\.*" | sed 's@^\([^ ]\+\) \(.*\)$@\1 = \2@'
  echo ""
  echo "=== Repository ==="
  echo "Remote:     ${remote} ($(get_url_from_remote ${remote}))";
  echo "+ User:       ${user}"
  echo "+ Host:       ${host}"
  echo "+ Port:       ${port}"
  echo "+ Repository: ${repo}"
  echo ""
  echo "=== Remote gitolite ==="
  command=info
  cmd=$(get_cmd "$command" "$user" "$host" "$port")
  exec ${cmd% |*} | head -n1
  exit 0;
fi;

commands=$(get_cmd "$command" "$user" "$host" "$port")
cmd="${commands% |*}"
real_cmd="${commands#*| }"

if [ -z "${debug}" ]; then
  echo "Executing '$real_cmd...'"
  exec $cmd
else
  debug "command:             {$command}"
  debug "translated command:  {$real_cmd}"
  debug "ssh command:         {$cmd}"
  echo "Debug mode. Not actually executing"
fi;
